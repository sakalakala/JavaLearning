20190410
今日bugs：
	(1)方法声明无效，需要返回类型————如果构造函数出现，则有可能是函数名和类名不一致（是不是打错了）；
1.关键字final————最终类/方法/变量
	修饰的类不可以别继承；
	修饰的方法不可以被覆盖，但可以覆盖未被final修饰的方法；
	修饰的变量是一个常量，只能复制一次，使用数据不变时进行final化，此时数据多也被静态化；被final修饰的变量名称规范：所有字母都大写，由多个单词组成则用_进行分隔；
		注意：单例设计模式时懒汉式不可以加final，饿汉可以；
			  全局常量：public static final 
2.抽象类
	抽象事物：描述一个事物，却没有足够的信息；
	抽象关键字(abstract)；
	面对抽象事物，虽然不具体但是可以简单化，不用面对具体的事物；
	特点：
		(1)抽象方法一定定义在抽象类中，都需要用abstract来修饰；
		(2)抽象类不能实例化，不能用new关键字来创建对象；
		(3)只有子类覆盖了所有的抽象方法之后，子类具体化，子类就可以创建对象；
	    (4)抽象类也是不断地向上抽取而来的，抽取了方法的声明而不确定具体的方法内容；由不同的子类来完成具体的方法内容；
	注意：
		(1)抽象类中有构造函数，抽象类的构造函数虽然不能给抽象类对象实例化，因为抽象类不能创建对象，但是抽象类有子类，它的构造函数可以子类的对象实例化；
			抽象类和一般类的异同点：
				相同：都是用来描述事物，都可以进行属性和行为的描述；
				不同：抽象类描述事物的信息不具体，一般类描述事物的信息具体；
					  抽象类中可以定义抽象方法，一般类不行；
					  抽象类不可以实例化，一般类可以；
		(2)抽象类一定是个父类，因为它必须依赖子类覆盖抽象方法才能实例化方法；
		(3)抽象类中可以不定义抽象方法，仅仅是让该类不能创建对象；
		(4)关键字abstract什么关键字不能共存？———提示：非法的修饰符组合；
			final(一定要有子类;
			private(无法覆盖)；
			static(可直接调用方法);
3.接口：抽象类中所有方法都是抽象是，可以把抽象类用另一种形式来表示。
	(1)关键字interface
	(2)接口中的成员和class定义不同之处：I.全局常量 II.抽象方法；且都有固定修饰符,共性：成员都用public修饰(public static可以省略);
	(3)特点：I.不可以实例化；
			 II.需要覆盖了接口中所有抽象方法的子类才可以实例化，否则该子类还是一个抽象类；
			 III.接口是用来被实现的；