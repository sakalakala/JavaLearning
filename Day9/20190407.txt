20190407
1.基本数据类型参数传递
  引用数据类型参数传递	main入栈，类中成员变量的值在对象中（初始化值为0），显初始化
2.构造函数（对象一建立，设定的参数就被初始化完毕）
	(1)一般函数——用于描述事物应该具备的功能
	   构造函数——也是功能，但是该功能特殊，专门用于给对象初始化
	(2)构造函数的格式：
		I.函数名和类名相同
		II.没有返回值类型
		III.没有具体的返回值 
	(3)一般函数和构造函数运行上的区别：
		I.构造函数在对象创建时就执行了，且只执行一次；
		  一般函数是在对象创建后，需要时才被对象调用，但可以调用多次；
	(4)多构造函数在类中为重载形式
	(5)存储形式
3.默认构造函数
	(1)在定义的每一个类中都有一个与该类同名的默认的空参数构造函数；
	(2)一旦类中自定义了构造函数，这个默认的构造函数就没有了，此时在调用对象时必须给其初始化以赋值！！！
		class Car{
			Car(){}；//类中默认的空参数构造函数，专门用于创建对象初始化用的。
		}
	(3)构造函数有return语句，用于结束函数；
	(4)一般函数void Person()编译可以通过，但通常建议一般函数的第一个单词名称为小写，大写为构造函数，可以存在但不符合书写规范
4.私有构造函数：限制他人创建对象，只在本类中使用，一旦私有化其它程序就无法创建该类的对象（因为无法对创建的对象初始化）
	(1)私有构造函数的调用
		I.构造函数只能被构造函数调用，不能直接被一般方法调用；
		II.构造函数间可以通过关键字this来访问；
		   this:代表的是对象,每个方法进入栈内存时都有this，只要用对象调用了一个方法，方法内就持有一个引用，引用指向调用我的对象
			(?)
				this带上参数列表的方式就可以访问本类中的其他构造函数，如this("lisi"):访问的就本类中带一个字符串参数的构造函数；
		   注意：用于调用构造函数的this语句必须定义在构造函数的第一行，因为初始化动作要先执行！！！
				一个方法中只能调用一个this！！！
5.关键字区分变量同名
	(1)只要直接被对象调用的方法都持有this引用（凡是访问了对象中高端数据的方法都持有this引用）
	(2)当局部变量和成员变量名称相同时会出现局部赋值给局部，赋值给成员失败，此时可以通过this关键字进行区分，有this时是赋值给成员变量；
6.this关键字的应用
7.静态方法：用类名直接调用方法以防止无意义的对象建立，但必须通过指定修饰符修饰，关键字为static
  static：用于修饰成员的静态关键字
  什么时候函数徐亚静态修饰呢？该函数没有访问过对象中的属性时，就需要用静态修饰。建立太多的对象可能会浪费内存。
8.静态变量：将共同的数据抽取出来让所有成员共享，静态后就不会存放在堆内存的每个对象内了（节省内存）
  关键字为static
9.静态关键字：static，为成员修饰符
  特点：被静态修饰的成员可以直接被类名所调用；
		静态成员优先于对象存在；会随着类的加载而加载（会随着类的消失而消失）。其生命周期很长；
10.静态内存
	方法区（数据共享区/代码存放区）———— static Demo区(static Demo(){})
						———— static code(staticDemo main())
	类自解码文件，在方法区开辟空间（如Person类在方法区开辟string name\int age\void show()……)
				static code内存放static country = "cn";……,自此person在方法区内的空间被分配完毕
	栈：代码运行区
	然后堆内开辟新的对象，Person方法进栈，指向堆的首地址，赋值完毕，结束后方法出栈，再将堆中的首地址赋给主函数中的变量P
	当调用p.show时，方法void show进栈，输出结果后show出栈
	而当调用Person.sleep时，因为是类名调用，所以都直接在方法区的静态区内寻找，找到后直接进栈运行，里面没有this（未指向任何对象）
	所以静态成员优先于对象存在
	注意：(1)错误：无法从静态上下文中引用非静态变量：静态内容访问非静态成员，此时没有对象无法访问，静态只能访问静态成员；
		  (2)非静态成员可以访问静态成员；
		  (3)静态方法中不能出现this或super关键字，因为静态先在对象后在，所以对于静态来说对象没有意义；
		  (4)主函数是静态的；
	使用：直接用于修饰成员
	使用时机：成员变量：如果数据在所有对象中都是一样的，则直接静态修饰；
			  成员函数：如果函数没有访问过对象中的属性数据，则该函数可设为静态的；
11.成员变量和静态变量的区别
	(1)名称上的区别
		成员变量/实例变量；
		静态变量/类变量；
	(2)内存存储上的区别
		成员变量存储在堆内存的对象中；
		静态变量存储到方法区的静态区中；
	(3)生命周期不同
		成员变量随着对象的出现而出现，随着对象的消失而消失；
		静态变量随着类的出现而出现，随着类的消失而消失；
	(4)成员变量可能在堆内存内出现多次；
	   静态变量在内存中只有一份；
12.全局变量	public
13.静态代码块：随着类的加载而执行，而且只执行一次
   作用：用于给类进行初始化（类比：构造函数是给对象初始化的）
   运用场景：类不需要创建对象，但是需要初始化，此时将部分代码存储到静态代码块中
   注意：一个类中先执行其静态代码块（完成初始化），再执行其主函数和主函数所调用的类的静态代码块   